""" opentrons.execute: functions and entrypoint for running protocols

This module has functions that can be imported to provide protocol
contexts for running protocols during interactive sessions like Jupyter or just
regular python shells. It also provides a console entrypoint for running a
protocol from the command line.
"""

import argparse
import asyncio
import logging
import sys
import threading
from typing import Any, Callable, Dict, List, Optional, TextIO

from opentrons import protocol_api, robot, legacy_api, __version__
from opentrons.protocol_api import execute as execute_apiv2
from opentrons import commands
from opentrons.config import feature_flags as ff
from opentrons.protocols.parse import parse
from opentrons.protocols.types import JsonProtocol
from opentrons.hardware_control import API

_HWCONTROL: Optional[API] = None
#: The background global cache that all protocol contexts created by
#: :py:meth:`get_protocol_api` will share


def get_protocol_api() -> protocol_api.ProtocolContext:
    """
    Build and return a :py:class:`ProtocolContext` connected to the robot.

    This can be used to run protocols from interactive Python sessions
    such as Jupyter or an interpreter on the command line:

    .. code-block:: python

        >>> from opentrons.execute import get_protocol_api
        >>> protocol = get_protocol_api()
        >>> instr = protocol.load_instrument('p300_single', 'right')
        >>> instr.home()

    When this function is called, modules and instruments will be recached.
    """
    if not _HWCONTROL:
        # Build a hardware controller in a worker thread, which is necessary
        # because ipython runs its notebook in asyncio but the notebook
        # is at script/repl scope not function scope and is synchronous so
        # you can't control the loop from inside. If we update to
        # IPython 7 we can avoid this, but for now we can't
        def _build_hwcontroller():
            global _HWCONTROL
            try:
                loop = asyncio.get_event_loop()
            except RuntimeError:
                loop = asyncio.new_event_loop()
            _HWCONTROL = loop.run_until_complete(
                API.build_hardware_controller())

        thread = threading.Thread(
            target=_build_hwcontroller,
            name='Hardware-controller-builder')
        thread.start()
        thread.join()

    context = protocol_api.ProtocolContext(hardware=_HWCONTROL)
    context._hw_manager.hardware.cache_instruments()
    context._hw_manager.hardware.discover_modules()
    return context


def get_arguments() -> argparse.ArgumentParser:
    """ Get the argument parser for this module

    Useful if you want to use this module as a component of another CLI program
    and want to add its arguments.
    """
    parser = argparse.ArgumentParser(description='Run an OT-2 protocol')
    parser.add_argument(
        '-l', '--log-level',
        choices=['debug', 'info', 'warning', 'error', 'none'],
        default='warning',
        help='Specify the level filter for logs to show on the command line. '
        'The logs stored in journald or local log files are unaffected by '
        'this option and should be configured in the config file. If '
        '\'none\', do not show logs')
    parser.add_argument(
        '-a', '--api-level',
        choices=['auto', '1', '2'],
        default='auto',
        help='Override the automatic deduction of protocol API level to use '
        'when executing this protocol. By default, the metadata (if any), '
        'imports, and structure of the protocol are examined; if this isn\'t '
        'working, you can specify -a 1 or -a 2 here.'
    )
    parser.add_argument(
        'protocol', metavar='PROTOCOL',
        type=argparse.FileType,
        help='The protocol file to execute. If you pass \'-\', you can pipe '
        'the protocol via stdin; this could be useful if you want to use this '
        'utility as part of an automated workflow.')
    return parser


def execute(protocol_file: TextIO,
            propagate_logs: bool = False,
            log_level: str = 'warning',
            emit_runlog: Callable[[Dict[str, Any]], None] = None):
    """
    Run the protocol itself.

    This is a one-stop function to run a protocol, whether python or json,
    no matter the api verson, from external (i.e. not bound up in other
    internal server infrastructure) sources.

    To run an opentrons protocol from other places, pass in a file like
    object as protocol_file; this function either returns (if the run has no
    problems) or raises an exception.

    To call from the command line use either the autogenerated entrypoint
    ``opentrons_execute`` or ``python -m opentrons.execute``.

    If the protocol is using Opentrons Protocol API V1, it does not need to
    explicitly call :py:meth:`.Robot.connect`
    or :py:meth:`.Robot.discover_modules`, or
    :py:meth:`.Robot.cache_instrument_models`.

    :param file-like protocol_file: The protocol file to execute
    :param propagate_logs: Whether this function should allow logs from the
                           Opentrons stack to propagate up to the root handler.
                           This can be useful if you're integrating this
                           function in a larger application, but most logs that
                           occur during protocol simulation are best associated
                           with the actions in the protocol that cause them.
                           Default: ``False``
    :type propagate_logs: bool
    :param log_level: The level of logs to emit on the command line.. Default:
                      'warning'
    :type log_level: 'debug', 'info', 'warning', or 'error'
    :param emit_runlog: A callback for printing the runlog. If specified, this
                        will be called whenever a command adds an entry to the
                        runlog, which can be used for display and progress
                        estimation. If specified, the callback should take a
                        single argument (the name doesn't matter) which will
                        be a dictionary (see below). Default: ``None``

    The format of the runlog entries is as follows:

    .. code-block:: python

        {
            'name': command_name,
            'payload': {
                 'text': string_command_text,
                  # The rest of this struct is command-dependent; see
                  # opentrons.commands.commands. Its keys match format
                  # keys in 'text', so that
                  # entry['payload']['text'].format(**entry['payload'])
                  # will produce a string with information filled in
             }
        }


    """
    stack_logger = logging.getLogger('opentrons')
    stack_logger.propagate = propagate_logs
    stack_logger.setLevel(getattr(logging, log_level.upper(), logging.WARNING))
    contents = protocol_file.read()
    protocol = parse(contents, protocol_file.name)
    if ff.use_protocol_api_v2():
        context = get_protocol_api()
        if emit_runlog:
            context.broker.subscribe(
                commands.command_types.COMMAND, emit_runlog)
        context.home()
        execute_apiv2.run_protocol(protocol,
                                   simulate=False,
                                   context=context)
    else:
        robot.connect()
        robot.cache_instrument_models()
        robot.discover_modules()
        robot.home()
        if emit_runlog:
            robot.broker.subscribe(
                commands.command_types.COMMAND, emit_runlog)
        if isinstance(protocol, JsonProtocol):
            legacy_api.protocols.execute_protocol(protocol)
        else:
            exec(protocol.contents, {})


def _print_runlog(command: Dict[str, Any]):
    when = 'Begin:' if command['payload']['$'] == 'before' else 'End:'
    print(' '.join([
        '\t' * command['level'],
        when,
        command['payload']['text'].format(**command['payload']['text'])]))


def _main(argv: List[str]) -> int:
    """ Handler for command line invocation to run a protocol.

    :param argv: The arguments the program was invoked with; this is usually
                 :py:attr:`sys.argv` but if you want to override that you can.
    :returns int: A success or failure value suitable for use as a shell
                  return code passed to :py:meth:`sys.exit` (0 means success,
                  anything else is a kind of failure).
    """
    parser = get_arguments()
    # don't want to add this in get_arguments because if somebody upstream is
    # using that parser they probably want their own version
    parser.add_argument(
        '-v', '--version', action='version', version=__version__)
    parser.add_argument(
        '-n', '--no-print-runlog', action='store_true',
        description='Do not print the commands as they are executed')
    args = parser.parse_args(argv)
    protofile = args.protocol.read()
    printer = None if args.no_print_runlog else _print_runlog
    if args.log_level != 'none':
        stack_logger = logging.getLogger('opentrons')
        stack_logger.addHandler(logging.StreamHandler(sys.stdout))
        log_level = args.log_level
    else:
        log_level = 'warning'
    execute(protofile, log_level=log_level, emit_runlog=printer)
    return 0


def main():
    """ Entrypoint for the setup.py console_script """
    return _main(sys.argv)


if __name__ == '__main__':
    sys.exit(main())
